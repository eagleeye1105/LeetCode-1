# 10. 正则表达式匹配

[链接](https://leetcode-cn.com/problems/regular-expression-matching/description/)

给定一个字符串 (`s`) 和一个字符模式 (`p`)。实现支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符。
'*' 匹配零个或多个前面的元素。
```

匹配应该覆盖**整个**字符串 (`s`) ，而不是部分字符串。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "a*"
输出: true
解释: '*' 代表可匹配零个或多个前面的元素, 即可以匹配 'a' 。因此, 重复 'a' 一次, 字符串可变为 "aa"。
```

**示例 3:**

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个('*')任意字符('.')。
```

**示例 4:**

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 'c' 可以不被重复, 'a' 可以被重复一次。因此可以匹配字符串 "aab"。
```

**示例 5:**

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

**思路分析**

[参考链接](https://cloud.tencent.com/developer/article/1092371)

![](https://ask.qcloudimg.com/http-save/yehe-1622140/o0r7xcsmml.jpeg?imageView2/2/w/1620) 

需要一个二维数组`dp[j][i]`（j、i分为表示p和s的长度），表示p[0]-p[j-1]是否与s[0]-s[i-1]匹配（注意：由于`dp[0][0]`表示的是空串，因此`dp[j][i]`对应的应该是p[j-1]和s[i-1]）

首先考虑初始化：

- 初始化第一行：由于`dp[0][i]`表示的是p为空字符串，s是否匹配，`dp[0][0]=1`，其余的均为0
- 初始化第一列：由于`dp[j][0]`表示的是s为空字符串，p是否匹配，可知只有`x*y*`的模式，才可能是1，因此可知`dp[1][0]`肯定是0，j大于1的时候，若p[j-1]为`‘*’`,且`p[j-2][0]`为1时，才为1

因此有：

```c++
//第一行的初始化：
dp[0][0] = 1;
for(int i=1; i<s.size(); ++i)
    dp[0][i] = 0;

//第一列的初始化
dp[j][1] = 0;
for(int j = 2; j<p.size(); ++j)
    dp[j][0] = p[j-1]=='*' && dp[j-2][0];
```

现在考虑剩余元素的`dp[j][i]`的递推公式分析：

- 如果p[j-1]为'*',则其有两种情况：
  - 匹配为空串，则`dp[j][i]`的值与`dp[j-2][i]`的值相等
  - 匹配一个或多个相同的字符，`dp[j][i]`为1的条件是：
    - p[j-2]与s[i-1]相等，或p[j-2]的字符为'.'
    - `dp[j][i-1]`为1

```c++
//如果p[j-1]为*
dp[j][i] = dp[j-2][i] || ( p[j-2]==s[i-1] || p[j-2]=='.' ) && dp[j][i-1];
```

- 如果p[j-1]不为'*'
  - 如果s[i-1]等于p[j-1]，且`dp[j-1][i-1]`为1，则`p[j][i]`为1
  - 如果p[j-1]等于'.'，且`dp[j-1][i-1]`为1，则`p[j][i]`为1

```c++
//如果如果p[j-1]不为*
dp[j][i] = (p[j-1] == s[i-1] || p[j-1] == '.') && dp[j-1][i-1]
```


**我的实现**

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int sLen = s.size();
        int pLen = p.size();
        vector<vector<int>> dp(pLen+1, vector<int>(sLen+1,0));
        
        //初始化第1行，剩下的dp[0][i]本身已经为0，不需要处理
        dp[0][0]=1;
        
        //初始化第1列
        //dp[1][0] = 0;
        for(int j=2; j<=pLen; ++j)
            dp[j][0] = p[j-1]=='*' && dp[j-2][0];
        
        //开始递推
        for(int i=1; i<=sLen; ++i)
            for(int j=1; j<=pLen; ++j)
            {
                if(p[j-1]=='*')
                    //匹配空串 或 重复字符
                    dp[j][i] = dp[j-2][i] || (p[j-2]==s[i-1] || p[j-2]=='.') && dp[j][i-1];
                else
                    //字符相等 或 p为.
                    dp[j][i] = (p[j-1] == s[i-1] || p[j-1] == '.') && dp[j-1][i-1];
            }
        
        return dp[pLen][sLen];
    }
};
```

