# 41. 缺失的第一个正数

[链接](https://leetcode-cn.com/problems/first-missing-positive/description/)

给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

**示例 1:**

```
输入: [1,2,0]
输出: 3
```

**示例 2:**

```
输入: [3,4,-1,1]
输出: 2
```

**示例 3:**

```
输入: [7,8,9,11,12]
输出: 1
```

**说明:**

你的算法的时间复杂度应为O(*n*)，并且只能使用常数级别的空间。

**思路分析**

可根据数组中数字的范围分类四类（设数组长度为n）：

- 1.数组中所有元素都在(-无穷,0]，即没有正整数的情况，此时所求值为1
- 2.数组中所有元素都在[n+1,+无穷)，则所求值1
- 3.数组中所有元素都在[1,n]，则所求值为n+1
- 4.部分元素在[1,n]，则所求值为[1,n]中没有填上的第一个位置

可以看到，只有情况4是比较难考虑的，因此可以这样做：假设一个数组元素值为i，如果i在[1,n]的范围内，则将其放在数组下标为i-1的位置。对于元素值不在[1,n]范围的值，则不做处理，直接遍历下一个元素。一次数组遍历后，我们就可以根据“第一个不符合值为i，但不在下标为i-1位置的元素，其下标+1就是所求值”的原则来求值

现在再来重新考虑以上四种情况：

- 1.由于所有数都不在[1,n]范围，所以下标为0的元素就符合原则，因此得到答案1
- 2.由于所有数都不在[1,n]范围，所以下标为0的元素就符合原则，因此得到答案1
- 3.由于遍历完数组，没有找到不符合原则的元素，将遍历游标+1（遍历完时遍历游标值等于n）返回，则就是所求答案n+1
- 4.根据示例2，根据以上方法处理好的数组是[1,-1,3,4]，此时值为-1的值就是第一个不符合的元素，其下标为1，因此返回1+1，所求为2

[参考链接](http://www.cnblogs.com/AnnieKim/archive/2013/04/21/3034631.html)

**我的实现**

```c++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        if(nums.empty()) return 1;
        int n = nums.size();
        int i=0;
        while(i<n)
        {
            if( 1 <= nums[i] && nums[i] <=n && nums[nums[i]-1]!=nums[i])
                swap(nums[nums[i]-1],nums[i]);
            else ++i;
        }
        
        for(int i=0; i<n; ++i)
            if(nums[i]!=i+1) return i+1;
        
        return n+1;
    }
};
```

